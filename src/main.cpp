#include <Arduino.h>

//librarys - still need to import
// #include <SoftwareSerial.h>
#include <SD.h>
#include <SPI.h>
#include <L298N.h>
#include <Encoder.h>
#include "RotaryEncoder.h"
#include <Wire.h>
#include "SpeedControl.h"

#include<Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#define OLED_RESET    -1
#define SCREEN_ADDRESS 0x3C
#define SENSOR_ADDRESS 0X38
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define RIGHT_OFFSET 55

// // 'Mines-Logo-triangle-blue', 128x32px
// const unsigned char Mines_Logo[] PROGMEM = {
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x50, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x98, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5c, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x02, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x04, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0xe0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0xe0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0x21, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
// };

// // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 528)
// const int myBitmapallArray_LEN = 1;
// const unsigned char* myBitmapallArray[1] = {
// 	Mines_Logo
// };

// #include "TestControl.h"

// Pins used so far 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, A0, A1, A2, A3, A4, A5
// Pins not used 0, 1, 13

//pin setup
const byte motor1pin1 = 1;
const byte motor1pin2 = A0; // may get rid of and short in order to only drive in one direction
const byte motor1speedpin = 9;
// L298N linear_motor(motor1speedpin,motor1pin1,motor1pin2);
// Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,&Wire, OLED_RESET);
RotaryEncoder selector(4,A3,7);

const byte motor2pin1 = 1;
const byte motor2pin2 = A0; // ditto
const byte motor2speedpin = 5;
L298N wheel_motor(motor2pin1,motor2pin2, motor2speedpin);

const byte loadcell_dt = 6;
const byte loadcell_sck = 8;

const byte sd_cs = 10;

const byte eStopPin = 12;

SpeedControl linearMotorControl;

// SoftwareSerial espSerial(8, A3); //(RX, TX) A voltage divider is needed for the A3 pin


/* PIN ASSIGMENTS
* For Encoders, one of each should be on on encoder pin for best results. both for even better results
* 2 and 3 are already assigned to one of the motors. Currently will be looking at all pin assignments.
*/
const byte encoder1_dt = 2; // enable software interupts during loop
const byte encoder1_clk = A1;
const byte encoder2_dt = 3;
const byte encoder2_clk = A2;
// const int ammeterPin = 11;

Encoder LinearMotor_enc(encoder1_dt,encoder1_clk);
Encoder WheelMotor_enc(encoder2_dt,encoder2_clk);



void setup() {
  // put your setup code here, to run once:

  Serial.begin(9600);
  // espSerial.begin(9600); //if seeing gibberish change 9600 to 115200
  while (!Serial) {}

  //display initialization
  // if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
  //   for(;;); // Don't proceed, loop forever
  // }

  //Motor setup
  linearMotorControl.setPin(2,11,3,7);//test pins
  linearMotorControl.setReversePolarity(false);
  linearMotorControl.setCPR(2821);
  linearMotorControl.setMotorMaxSpeed(4.183); //Hz
  const float KU = 47;
  const float TU = 2;
  const float ZN_coeff[3] = {0.33*KU,0.66*KU/TU,0.11*TU*KU};
  linearMotorControl.setPIDValue(ZN_coeff[0],ZN_coeff[1],ZN_coeff[2]);


  // display.clearDisplay();
  // display.drawBitmap(0,0,Mines_Logo,128,32,WHITE);
  // display.display();  //initialize display upon boot
  // display.setTextColor(WHITE);
  // display.setTextSize(1);

  //Estop button

  //Driver pins

  //Load cell pins

  //Ammeter pins
  // pinMode(ammeterPin, INPUT);

  linearMotorControl.setSpeed(3);
}

void loop() {
  // delay(200);
  linearMotorControl.controlLoop();
  // analogWrite(11,255);
  // digitalWrite(2,HIGH);
  Serial.println(linearMotorControl.currentVelocity);
  // analogWrite(11,255);

  float spoolRadius = 0.02; //measure and find value (meters) TODO

  //ESP8266 stuff
  // if (espSerial.available()) {
  //   Serial.write(espSerial.read());  // Read from ESP8266 and send to Serial Monitor
  // }
  
  // if (Serial.available()) {
  //   espSerial.write(Serial.read());  // Send Serial Monitor input to ESP8266
  // }

  //Estop

  //Stop motors
  // digitalWrite(motor1pin1, LOW);
  // digitalWrite(motor1pin2, LOW);
  // digitalWrite(motor2pin1, LOW);
  // digitalWrite(motor2pin2, LOW);
  
  // analogWrite(motor1speedpin, 0);
  // analogWrite(motor2speedpin, 0);

  // while (true) {
  // if (digitalRead(eStopPin) == HIGH) {
  //   Serial.println(F("E-Stop Released. Restart required."));
  //   delay(1000);
  //   }
  // }
  

  //Constants

  int w_angularVelocity=200; // NOT THE ACTUAL NUMBER DO NOT DO 200!!!!
  const float radius = 0.073; // in meters

  //Get slip value
  // Serial.println("Please input slip value: ");
  // int slipValue = getSerialInput();
  // float slipValue=Test_setup();
  // Serial.println(slipValue);
  
  // float linearVelocity = (1-slipValue)*w_angularVelocity*radius;
  // float wheelAngularVelocity = linearVelocity*spoolRadius; // not totally sure on this calculation have someone double check

  // int pwmValue = map(wheelAngularVelocity, 0, w_angularVelocity, 0, 255);
  // pwmValue = constrain(pwmValue, 0, 255); // Ensure within limits


  // Serial.println(pwmValue);
  // linear_motor.setSpeed(255);
  // linear_motor.run(L298N::FORWARD);
  // delay(3000);
  // linear_motor.setSpeed(255);



  //Move forward
  // linear_motor.run(L298N::BACKWARD);
  // delay(3000);
  // digitalWrite(motor1pin1,  HIGH);
  // digitalWrite(motor1pin2, LOW);
  // digitalWrite(motor2pin1, HIGH);
  // digitalWrite(motor2pin2, LOW);
  // delay(3000);

  //Write in SD card, slip value, linear velocity, force (Load Cell), amperage (ammeter)
}

float Test_setup(){
  float slip_ratio = 0;
  while(true){
    // Serial.println(selector.count);
    // display.clearDisplay();
    // display.setTextSize(1);
    // display.setTextColor(WHITE);
    // display.println(F("Slip:"));

    if(selector.RotaryPressed()){
      break;
    }
    selector.ReadRotary();
    slip_ratio = selector.count%21*0.05;
    
  //Display the values the user is selecting
    // display.print(slip_ratio);
    // display.display();
    // display.setCursor(0,0);
  }
  // display.clearDisplay();
  // display.display();
  return slip_ratio;
}