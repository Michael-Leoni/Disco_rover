#include <Arduino.h>

//librarys - still need to import
// #include <SoftwareSerial.h>
#include <Encoder.h>
#include "SpeedControl.h"

// // 'Mines-Logo-triangle-blue', 128x32px
// const unsigned char Mines_Logo[] PROGMEM = {
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x50, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x98, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5c, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x02, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x04, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0xe0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0xe0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0x21, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
// };

// // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 528)
// const int myBitmapallArray_LEN = 1;
// const unsigned char* myBitmapallArray[1] = {
// 	Mines_Logo
// };

// #include "TestControl.h"

// Pins used so far 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, A0, A1, A2, A3, A4, A5
// Pins not used 0, 1, 13

//pin setup
const byte motor1pin1 = 1;
const byte motor1pin2 = A0; // may get rid of and short in order to only drive in one direction
const byte motor1speedpin = 9;
// L298N linear_motor(motor1speedpin,motor1pin1,motor1pin2);
// Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,&Wire, OLED_RESET);

const byte motor2pin1 = 1;
const byte motor2pin2 = A0; // ditto
const byte motor2speedpin = 5;

const float ZN_coeff[3] = {0.33,0.66,0.11};

SpeedControl LinearMotor;

// SoftwareSerial espSerial(8, A3); //(RX, TX) A voltage divider is needed for the A3 pin


/* PIN ASSIGMENTS
* For Encoders, one of each should be on on encoder pin for best results. both for even better results
* 2 and 3 are already assigned to one of the motors. Currently will be looking at all pin assignments.
*/
const byte encoder1_dt = 2; // enable software interupts during loop
const byte encoder1_clk = A1;
const byte encoder2_dt = 3;
const byte encoder2_clk = A2;
// const int ammeterPin = 11;


void motorControlSetup(SpeedControl& controller, const uint8_t pin_dir, const uint8_t pwm_pin, const uint8_t encA_pin, const uint8_t encB_pin, const float KU, const float TU);


void setup() {
  // put your setup code here, to run once:

  Serial.begin(9600);
  // espSerial.begin(9600); //if seeing gibberish change 9600 to 115200
  while (!Serial) {}

  //display initialization
  // if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
  //   for(;;); // Don't proceed, loop forever
  // }

  //Motor setup
  motorControlSetup(LinearMotor,2,11,3,7,47,2);

  // display.clearDisplay();
  // display.drawBitmap(0,0,Mines_Logo,128,32,WHITE);
  // display.display();  //initialize display upon boot
  // display.setTextColor(WHITE);
  // display.setTextSize(1);

  //Estop button

  //Driver pins

  //Load cell pins

  //Ammeter pins
  // pinMode(ammeterPin, INPUT);
  LinearMotor.setSpeed(1);
  
}

void loop() {
  // delay(200);
  LinearMotor.controlLoop();
  // analogWrite(11,255);
  // digitalWrite(2,HIGH);
  Serial.println(LinearMotor.currentVelocity);
  // analogWrite(11,255);

  float spoolRadius = 0.02; //measure and find value (meters) TODO

  //ESP8266 stuff
  // if (espSerial.available()) {
  //   Serial.write(espSerial.read());  // Read from ESP8266 and send to Serial Monitor
  // }
  
  // if (Serial.available()) {
  //   espSerial.write(Serial.read());  // Send Serial Monitor input to ESP8266
  // }

  //Estop

  //Stop motors
  // digitalWrite(motor1pin1, LOW);
  // digitalWrite(motor1pin2, LOW);
  // digitalWrite(motor2pin1, LOW);
  // digitalWrite(motor2pin2, LOW);
  
  // analogWrite(motor1speedpin, 0);
  // analogWrite(motor2speedpin, 0);

  // while (true) {
  // if (digitalRead(eStopPin) == HIGH) {
  //   Serial.println(F("E-Stop Released. Restart required."));
  //   delay(1000);
  //   }
  // }
  

  //Constants

  int w_angularVelocity=200; // NOT THE ACTUAL NUMBER DO NOT DO 200!!!!
  const float radius = 0.073; // in meters

  //Get slip value
  // Serial.println("Please input slip value: ");
  // int slipValue = getSerialInput();
  // float slipValue=Test_setup();
  // Serial.println(slipValue);
  
  // float linearVelocity = (1-slipValue)*w_angularVelocity*radius;
  // float wheelAngularVelocity = linearVelocity*spoolRadius; // not totally sure on this calculation have someone double check

  // int pwmValue = map(wheelAngularVelocity, 0, w_angularVelocity, 0, 255);
  // pwmValue = constrain(pwmValue, 0, 255); // Ensure within limits


  // Serial.println(pwmValue);
  // linear_motor.setSpeed(255);
  // linear_motor.run(L298N::FORWARD);
  // delay(3000);
  // linear_motor.setSpeed(255);



  //Move forward
  // linear_motor.run(L298N::BACKWARD);
  // delay(3000);
  // digitalWrite(motor1pin1,  HIGH);
  // digitalWrite(motor1pin2, LOW);
  // digitalWrite(motor2pin1, HIGH);
  // digitalWrite(motor2pin2, LOW);
  // delay(3000);

  //Write in SD card, slip value, linear velocity, force (Load Cell), amperage (ammeter)
}


void motorControlSetup(SpeedControl& controller, const uint8_t pin_dir, const uint8_t pwm_pin, const uint8_t encA_pin, const uint8_t encB_pin, const float KU, const float TU){
  controller.setPin(pin_dir,pwm_pin,encA_pin,encB_pin);//test pins
  controller.setReversePolarity(false);
  controller.setCPR(2821);
  controller.setMotorMaxSpeed(4.183); //Hz
  controller.setPIDValue(KU*ZN_coeff[0],KU*ZN_coeff[1]/TU,KU*TU*ZN_coeff[2]);
}