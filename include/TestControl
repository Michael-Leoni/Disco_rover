#include <Wire.h>
#include<Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


#define OLED_RESET    -1
#define SCREEN_ADDRESS 0x3C
#define SENSOR_ADDRESS 0X38

#define FILENAME "data.txt"

#define BUTTON_PIN 7
#define ROTARY_A 2
#define ROTARY_B 3

#define SD_PIN 10

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define RIGHT_OFFSET 55
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,&Wire, OLED_RESET);

// 'Mines-Logo-triangle-blue', 128x32px
const unsigned char Mines_Logo[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x50, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x98, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5c, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x02, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x04, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0xe0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0xe0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0x21, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 528)
const int myBitmapallArray_LEN = 1;
const unsigned char* myBitmapallArray[1] = {
	Mines_Logo
};


static const char time_units[] = {'H','m','s'};
static const unsigned int time_unit_durations[] = {3600000,60000,1000};  // miliseconds corresponding to the units

byte duration_unit = 0; //selected unit by user for total test time.
byte interval_unit = 2; //selected unit by user for interval time. Corresponds to above code.

unsigned int timer;

float duration=0.5;
unsigned int duration_ms = 0;
byte interval=1;


bool aState;
bool aLastState;

float humi, temp;

AHT20 AHT;
SdFat SD;
SdFile dataFile;

/*
*Returns an quantity for iteration if the rotary wheel has been moved.
*/
unsigned short count = 0;
byte ReadRotary(){ 
   aState = digitalRead(ROTARY_A); // Reads the "current" state of the outputA
   // If the previous and the current state of the outputA are different, that means a Pulse has occured
   if (aState != aLastState){     
     // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
     if (digitalRead(ROTARY_B) != aState) { 
       count++;
     } else {
       count--;
     }
   } 
   aLastState = aState;
}

bool button_prev_pressed;
bool RotaryPressed(){
  bool button_read = digitalRead(BUTTON_PIN);
  bool pressed = false;
  if(button_read==LOW && button_prev_pressed==HIGH){
    pressed = true;
  }
  button_prev_pressed = button_read;
  return pressed;
}

void sendTempToHeater(byte temp){
  return;
}

void sendFluxToLights(unsigned short flux){
  return;
}


void setup() {
  Serial.begin(9600);
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    for(;;); // Don't proceed, loop forever
  }
  display.clearDisplay();
  display.drawBitmap(0,0,Mines_Logo,128,32,WHITE);
  display.display();  //initialize display upon boot
  display.setTextColor(WHITE);
  display.setTextSize(1);

    //   INITIALIZE SD CARD
  if(!SD.begin(SD_PIN,SPI_HALF_SPEED)){
    // display.clearDisplay();
    display.setCursor(0,0);
    display.println(F("SD err"));
    display.display();
    while(true);
  }


  byte chamber_temp = 0;   //degrees C
  unsigned short spectral_flux = 0; //Maximum of 1000 W;


  delay(2000);

  display.clearDisplay();
  display.display();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  //        INITIALIZE SENSOR
  AHT.begin();
  if (!AHT.getSensor(&humi, &temp)){
    display.println(F("SE"));
    display.display();
    while(true);
  }



  //    INITIALIZE PINS
  pinMode(ROTARY_A,INPUT_PULLUP);
  pinMode(ROTARY_B,INPUT_PULLUP);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  //    INITIALIZE INTERRUPT SERVICE
  attachInterrupt(digitalPinToInterrupt(ROTARY_A),ReadRotary,CHANGE);
  attachInterrupt(digitalPinToInterrupt(ROTARY_B),ReadRotary,CHANGE);

  button_prev_pressed = digitalRead(BUTTON_PIN);
  aLastState = digitalRead(ROTARY_A);


  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);

  count=30;

    //        Initialize Program setup
  // Print air temp option until temperature selected:
  while(true){
    while(true){
      display.clearDisplay();
      display.setTextSize(1);
      display.println(F("Temp:"));
      display.println();
      display.setTextSize(2);

    if(RotaryPressed()){
      break;
    }

      //verify chamber_temp is in range.
      

      display.print(chamber_temp+count);
      display.drawCircle(display.getCursorX()+2, display.getCursorY()+3, 2, WHITE);  //Draw degree symbol
      display.print(F(" C"));
      display.display();
      display.setCursor(0,0);
    }


    chamber_temp = chamber_temp+count;
    count=800/10;



    //Temperature for chamber selected. Moving onto light flux

    while(true){
      display.setCursor(0, 0);
      display.clearDisplay();
      display.setTextSize(1);
      display.println(F("Light Flux:"));
      display.println();
      display.setTextSize(2);
      //check for encoder updates here. same as before.
      if(RotaryPressed()){
        break;
      }
      display.print(spectral_flux+count*10);
      display.print(" W");
      display.setTextSize(1);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-7);
      display.print("T: ");
      display.print(chamber_temp);
      display.display();

    }

    //update variables
    spectral_flux = spectral_flux+count*10;
    count=0;



  //Duration unti selection

    while(true){
      display.setTextColor(WHITE,BLACK);
      display.clearDisplay();
      display.setCursor(0, 0);
      display.println(F("Duration:"));
      display.println();
      display.print(F(" "));
      display.setTextSize(2);
    for(size_t i=0; i<3; i++){
      if((count)%3 == i){
        display.setTextColor(BLACK,WHITE);
      }
      display.print(time_units[i]);
      display.setTextColor(WHITE,BLACK);
      display.print(F(" "));
    }
    display.setTextSize(1);
    display.println();

    display.setTextSize(1);
    display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-15);
    display.print(F("P: "));
    display.print(spectral_flux);
    display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-7);    
    display.print(F("T: "));
    display.print(chamber_temp);
    display.display();

    if(RotaryPressed()){
      break;
    }

    }

    duration_unit = count%3;
    count=0;



  // Duration quantity
    while(true){
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(WHITE,BLACK);
      display.setCursor(0, 0);

      display.println(F("Duration:"));
      display.println();


      display.setTextSize(2);
      display.print(duration+0.5*count,1);
      display.print(F(" "));
      display.print(time_units[duration_unit]);

  //Previous selections
      display.setTextSize(1);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-15);
      display.print(F("P: "));
      display.print(spectral_flux);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-7);    
      display.print(F("T: "));
      display.print(chamber_temp);
      display.display();

      display.display();

      if(RotaryPressed()){
        break;
      }
    }
    duration = duration+count*0.5;

    //Interval Unit Selection

    count = 0;
    while(true){
      display.setTextColor(WHITE,BLACK);
      display.clearDisplay();
      display.setCursor(0, 0);
      display.println(F("Interval:"));
      display.println();
      display.print(F(" "));
      display.setTextSize(2);
      for(size_t i=0; i<3; i++){
        if(count%3 == i){
          display.setTextColor(BLACK,WHITE);
        }
        display.print(time_units[i]);
        display.setTextColor(WHITE,BLACK);
        display.print(" ");
      }
      display.setTextSize(1);
      display.println();

      display.setTextSize(0.5);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-23);
      display.print(F("D: "));
      display.print(duration,1);
      display.print(" ");
      display.print(time_units[duration_unit]);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-15);
      display.print(F("P: "));
      display.print(spectral_flux);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-7);    
      display.print(F("T: "));
      display.print(chamber_temp);
      display.display();

      if(RotaryPressed()){
        break;
      }

    }
    interval_unit = count%3;
    count=0;


        //        INTERVAL SELECTION

    while(true){
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(WHITE,BLACK);
      display.setCursor(0, 0);

      display.println(F("Interval:"));
      display.println();


      display.setTextSize(2);
      display.print(interval+count,1);
      display.print(" ");
      display.print(time_units[interval_unit]);

  //Previous selections
      display.setTextSize(0.5);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-23);
      display.print(F("D: "));
      display.print(duration,1);
      display.print(F(" "));
      display.print(time_units[duration_unit]);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-15);
      display.print(F("P: "));
      display.print(spectral_flux);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-7);    
      display.print(F("T: "));
      display.print(chamber_temp);

      display.display();

      if(RotaryPressed()){
        break;
      }
    }
    interval = interval+count*0.5;

    //  Test Accept screen
    while(true){

      display.clearDisplay();
      display.setCursor(0,0);
      display.setTextColor(1);
      display.println(F("Begin"));
      display.println(F("Test?"));
      display.setTextSize(2);
      display.setCursor(display.getCursorX(), display.getCursorY()+2);
      display.print(" ");
      if(abs(count)%2==1){
        display.setTextColor(BLACK,WHITE);
      }
      display.print(F("Y"));
      display.setTextColor(WHITE,BLACK);
      display.print("  ");
      if(abs(count)%2==0){
        display.setTextColor(BLACK,WHITE);
      }
      display.print(F("N"));
      display.setTextColor(WHITE,BLACK);



      //Previous Selections
      display.setTextSize(1);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-32);
      display.print(F("I: "));
      display.print(interval,1);
      display.print(F(" "));
      display.print(time_units[interval_unit]);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-23);
      display.print(F("D: "));
      display.print(duration,1);
      display.print(F(" "));
      display.print(time_units[duration_unit]);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-15);
      display.print(F("P: "));
      display.print(spectral_flux);
      display.setCursor(SCREEN_WIDTH-RIGHT_OFFSET,  SCREEN_HEIGHT-7);    
      display.print(F("T: "));
      display.print(chamber_temp);

      display.display();

      if(RotaryPressed()){
        break;
      }
    }

    //If the user wants to begin the test
    if(abs(count)%2==1){
      count=0;
      timer=0;
      duration_ms = duration*time_unit_durations[duration_unit];
      sendTempToHeater(chamber_temp);
      sendFluxToLights(spectral_flux);
      display.clearDisplay();
      display.setCursor(0, 0);
      display.println(F("SD <-"));
      display.display();
      break;

      }
    //   break;
    // }
    else{}; //Repeat  program setup.
          // setup SD card output and file
    if(!dataFile.open(FILENAME,O_WRONLY | O_CREAT | O_EXCL)){
      display.println(F("SDerr"));
      display.display();
      while(true);
    }
  }

}


byte elipsis_count = 1;
void loop() {

  display.clearDisplay();
  display.setCursor(0,0);
  display.print(F("Running"));
  elipsis_count+=1;

    if(timer%(interval*time_unit_durations[interval_unit])==0){

      if(AHT.getSensor(&humi, &temp)){

        // dataFile.print(timer%time_unit_durations[interval_unit]);
        // dataFile.print(F(","));
        // dataFile.print(humi);
        // dataFile.print(F(","));
        // dataFile.println(temp);

      }
      else{
        // dataFile.println(F("Err"));
        
        display.println(F("S-E"));
      }
    }
    display.setTextSize(2);
    display.println();
    display.print(F("T-  "));
    display.print((float)(duration_ms - timer)/time_unit_durations[duration_unit],1);
    display.print(F(" "));
    display.println(time_units[duration_unit]);
    display.setTextSize(1);
    display.display();
    delay(500); // smallest interval of time that can be done is 500 ms
    timer+=500;



  if(timer>duration_ms){

    display.clearDisplay();
    display.setCursor(0, 0);
    display.println(F("Done"));
    display.display();

    // dataFile.close();

    display.println(F("Saved!"));
    display.println(F("power off and Remove Card."));
    display.display();
    while(true);  //loop forever until power is turned off
  }

  }